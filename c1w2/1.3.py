def find_min_skew_position(genome):
    i = 0
    skew = [0]
    result = []
    while i < len(genome):
        if (genome[i] == 'C'):
            skew.append(skew[len(skew) - 1] - 1)
        elif (genome[i] == 'G'):
            skew.append(skew[len(skew) - 1] + 1)
        else:
            skew.append(skew[len(skew) - 1])
        i += 1
    min_value = min(skew)
    return [i for i, x in enumerate(skew) if x == min_value]

def find_max_skew_position(genome):
    i = 0
    skew = [0]
    result = []
    while i < len(genome):
        if (genome[i] == 'C'):
            skew.append(skew[len(skew) - 1] - 1)
        elif (genome[i] == 'G'):
            skew.append(skew[len(skew) - 1] + 1)
        else:
            skew.append(skew[len(skew) - 1])
        i += 1
    max_value = max(skew)
    return [i for i, x in enumerate(skew) if x == max_value]

def approx_pattern_matching(pattern, genome, hamming):
    result = []
    for i in range(len(genome) - len(pattern) + 1):
        if (hamming_distance(genome[i:i + len(pattern)], pattern) <= hamming):
            result.append(i)
    return len(result)


def hamming_distance(s1, s2):
    i = 0
    count = 0
    while i < len(s1):
        if s1[i] != s2[i]:
            count += 1
        i += 1
    return count

if __name__ == "__main__":
    # file = open("e_coli.txt", "r")
    # genome = file.read().strip()
    # file.close()
    # print(*find_min_skew_position(genome), sep=' ')
    # s1 = "CTTTTTCGTCTCGTTCAAGTTATACAACCTGGCGAACGGTCAAGCTCAGTGTGGGATTCTTCTTGTATACGGTGCAGTAAGAGGCGGAGCGCCCGGGAACCATTTACGAGACGATCACACCAAGGTCCTCATGTAACTTGTACGAGAAGCGGCAACCGGGCCTGCGTCCTTAAGTCTCAATGCTAGATTCTCAATCGCCTGTTTACCGAGAAGGTTGACAGTGCACCTCCCTCGTACCGTGGGCCATTTTGTACGTGGGTCGGCCGCTCTTTCGGTCTCAGAGCTGTTCTTGAGCATTCAGATTGACAAGTAACGTATGGCTCTACAGACCTCGCACACCAGACGTTAGGACCGTTGTGCCGCGCTAACTAGATGTAAGTTTAGGCGTCCGGGTCAGAGTGCTTAAGTCACCACTAAATAACGAAGAACCTATGCGCGAAATCGTGGGGTAGCTAATAATCCGTGAACCCAATGATGTTAGTTTCCCTCCAGGGAACAAGTGCGATCCGATCTCTTCCATACCTCGTACTGATCTATCTCCCAATTAAGAATTTCGTTGTGATCCTTATAATTAGCTAGAGCGTGGACCCGGGCACAAAAACGCATTTCACTAATATTGCCATGATGTAATGCGCGCATGTGTGTAACCACCCGCATGATACCCGTCAGATCCAGATCGCCCCGGCAGAAAGATCCGTGCTTATTGTTGTCCATAGACGTAGTACTCTAAGTTAGACCCCTACTACCATCCGGTATTGAAATGGCCGCTCTATTAAGCCTTAGTCACTGAGCTTATACGAAAGAGAATGAGCGATTGCCCCCATGAGCTCTGCCCGTAGTGACGGAGCCATGAGCAAAGATGCCCCGCAACGAGTCAGTACGTCGTATCATGGGATCCCAAACGCCGCCAAGCTACGTAGCGTTACCACCTTGTTCAGTTACGAAGCACGCCGCAGCGTTATTGGTTGACATAATGTCAGATCGGCGCAGTGACGGCTCGCTGCTT"
    # s2 = "CAGCTCTTGAGGTATTATTCCTTCTGCTCAAAATTTCGAGGCTTCATCTTCTTCGACTTTAAAGTTTGTTGTGTCCCCCTCGCTGCCCTGGTATGATTAGCCTGCGTATGTCATCTAAGAGATCGAGCGACGTAACAGTAATGAAGGCGAATTTGGTGCCCCTAGGGAGTGCGGTGCTTTGTCCCTAACAGTATCCGTCCTCGTCGACGTAGTTCGCAACGGTGGACAGAACGAATATTAGGACGAGAGTATAAACGTCAAACTAAGGGTGCAGTTAACTAAGCCAACGGACATTCTTACTCGTTACCGTCAACCGGTCTCCTGTCCGGTGTACCAAACGCGTACAAGTCACGTTGGTGCTGTCGATAGCATTGAAGAGATTCTCGTTGCTTGCTTATGTCAATAACCTTCGTCGAATTTATTGGTATTGTCCCCTGGAGACGGCTTGTTAGGCGCTTGAAGTCGCTGGGATAGGTTCAGCGCGTCACAATGTATAAATACTGGGGACTGTTGGGCAACAATATACGCCGCGCCCCTTCGACATCTCTACTTTCAGCAGCTATAATATAAACAGGGCTTAAAATCACACGTCCGCCTCGAATATTTGTCGCGAGTCGCATTACAGTCCATCTCCATTTACCTGCTCCAGGGTTGCGGATCTTTCAGCGCGCTCAGAGTCGTATCCCGTTTAGGCATATGTCTAGAATGAAGTGTGGTTTCCGCACCTAAGGCCACCGAGGTTTTGTTCTATGAATTCCGACAAATACTATGTAGGTCTGTTACTTTAATTAGTCCCATACCAAAACTCGGTCACGACAATAGATTTCACACGCCACTAGTATCCTCAACGATGCCTATTGTAAATGAAGACCGCTCTCGCCCTTTAACCCGAGACCTTGCGGCCATCATTCATCCTGCCCTCAGACGATGCGTGATACACCTCTCCTTCAGTCCAACCAATTGGGCCGGACACATTAATGCGCCCTCGTATGAGCGATTGGGAAAT"
    # print(hamming_distance(s1, s2))
    pattern = "GCGGTT"
    genome = "TTTCATGGACAATAAAGCTAATTATCGGGAGCTCATTGGAGTGCTGGGTACCGGAGCTGCAGTCGGAGGAAATCGACGCACGATAAGCCACAGTGGTCCAACGGCCCCTTCTAAGGATTCTTCAAGTGCACAGGCGGTTTTCGCTAGTGCAATCACGCACTTAGCGGACTGACCATTGTGGCACGTCCTTAGCCCAAACGCTATCGCCCAGCCCACCAAAGTGCGCGTGCGCTCGTAGCTCTGTTAAGAGTTTCGCCCTTCCTATAACTAATTCCAATTCCGTGGGACAGTAGAGGGACAATATGGAAC"
    hamming = 2

    print(approx_pattern_matching("CCC", "CATGCCATTCGCATTGTCCCAGTGA", 2))
    # print(find_max_skew_position("GCATACACTTCCCAGTAGGTACTG"))
    # print(approx_pattern_matching(pattern, genome, hamming), sep = ' ')
